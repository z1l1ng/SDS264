---
title: "Strings: In-class Exercises (Part 2)"
format:
  html: default
editor_options: 
  chunk_output_type: console
---

You can download this .qmd file from [here](https://github.com/proback/264_fall_2024/blob/main/11_strings_part2.qmd).  Just hit the Download Raw File button.

This uses parts of R4DS Ch 14: Strings and Ch 15: Regular Expressions (both the first and second editions).

## Manipulating strings

str functions to know for manipulating strings:

- str_length()
- str_sub()
- str_c()
- str_to_lower()
- str_to_upper()
- str_to_title()
- str_replace() *not in video examples*


```{r}
#| message: false
#| warning: false

library(tidyverse)

#spotify <- read_csv("Data/spotify.csv") 
spotify <- read_csv("https://proback.github.io/264_fall_2024/Data/spotify.csv")

spot_smaller <- spotify |>
  select(
    title, 
    artist, 
    album_release_date, 
    album_name, 
    subgenre, 
    playlist_name
  )

spot_smaller <- spot_smaller[c(5, 32, 49, 52, 83, 175, 219, 231, 246, 265), ]
spot_smaller
```


## Warm-up

0. Describe what EACH of the str_ functions below does. Then, create a new variable "month" which is the two digit month from album_release_date

```{r}
spot_new <- spot_smaller |>
  select(title, album_release_date) |>
  mutate(title_length = str_length(title),
         year = str_sub(album_release_date, 1, 4),
         title_lower = str_to_lower(title),
         album_release_date2 = str_replace_all(album_release_date, "-", "/"))
spot_new
         
max_length <- max(spot_new$title_length)

str_c("The longest title is", max_length, "characters long.", sep = " ")

spot_new |>
  mutate(month = str_sub(album_release_date,6, 7))
```

>> select 2 columns of album release data and title, then 
title length is how long the the album title is
year is the the year that it was released
title lower is title but lowercase
and album release date 2 replaces - with /, so we will have 

## Important functions for identifying strings which match

str_view() : most useful for testing
str_subset() : useful for printing matches to the console
str_detect() : useful when working within a tibble


1. Identify the input type and output type for each of these examples:

```{r}
str_view(spot_smaller$subgenre, "pop")
typeof(str_view(spot_smaller$subgenre, "pop"))
class(str_view(spot_smaller$subgenre, "pop"))

str_view(spot_smaller$subgenre, "pop", match = NA)
str_view(spot_smaller$subgenre, "pop", html = TRUE)

str_subset(spot_smaller$subgenre, "pop")

str_detect(spot_smaller$subgenre, "pop")
```


2. Use str_detect to print the rows of the spot_smaller tibble containing songs that have "pop" in the subgenre. (i.e. make a new tibble with fewer rows)

```{r}
spot_even_smaller <- spot_smaller |>
  mutate(sub_pop = str_detect(subgenre, "pop"))

spot_even_smaller |>
  filter(sub_pop)
```


3. Find the mean song title length for songs with "pop" in the subgenre and songs without "pop" in the subgenre.  

```{r}
spot_even_smaller |>
  mutate(title_length = str_length(title)) |>
  group_by(sub_pop) |>
  summarize(mean_title_length = mean(title_length))

spot_even_smaller |>
  mutate(title_length = str_length(title)) |>
  group_by(sub_pop) |>
  summarize(mean_title_length = mean(title_length)) |>
  mutate(sub_pop = ifelse(sub_pop,"Genre with pop", "Genre without pop"))
```


Producing a table like this would be great:

# A tibble: 2 × 2
  sub_pop mean_title_length
  <lgl>               <dbl>
1 FALSE                18.6
2 TRUE                 13.6

Producing a table like this would be SUPER great (hint: ifelse()):

# A tibble: 2 × 2
  sub_pop           mean_title_length
  <chr>                         <dbl>
1 Genre with pop                 13.6
2 Genre without pop              18.6


4. In the bigspotify dataset, find the proportion of songs which contain "love" in the title (track_name) by playlist_genre.

```{r}
bigspotify <- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2020/2020-01-21/spotify_songs.csv')

bigspotify
```

```{r}
bigspotify |>
  mutate(haslove = str_detect(track_name, "love")) |>
  group_by(playlist_genre) |>
  summarise(prop_love = mean(haslove, na.rm = TRUE))
```


## Matching patterns with regular expressions

^abc   string starts with abc
abc$   string ends with abc
.      any character
[abc]  a or b or c
[^abc] anything EXCEPT a or b or c

```{r}
# Guess the output!

str_view(spot_smaller$artist, "^K")

str_view(spot_smaller$album_release_date, "01$")

str_view(spot_smaller$title, "^.. ")

str_view(spot_smaller$artist, "[^A-Za-z ]")
```


5. Given the corpus of common words in stringr::words, create regular expressions that find all words that:

- Start with “y”.
- End with “x”
- Are exactly three letters long.
- Have seven letters or more.
- Start with a vowel.
- End with ed, but not with eed.
- Words where q is not followed by u. (are there any in `words`?)

```{r}
# Try using str_view() or str_subset()

# For example, to find words with "tion" at any point, I could use:
str_view(words, "tion")
str_subset(words, "tion")

#Start with “y”
str_view(words, "^y")

#End with “x”
str_view(words, "x$")

#Are exactly three letters long
str_view(words, "^[A-Za-z]{3}$") #OR
str_view(words, "^...$")

# Have seven letters or more.
str_view(words, "^.......")

#Start with a vowel.
str_view(words, "^[aeiou]")

#End with ed, but not with eed
str_view(words, "[^e]ed$")

#Words where q is not followed by u
str_view(words, "q[^u]")
```


## More useful regular expressions: 

\\d  - any number
\\s  - any space, tab, etc
\\b  - any boundary: space, ., etc.

```{r}
str_view(spot_smaller$album_name, "\\d")
str_view(spot_smaller$album_name, "\\s")
str_view_all(spot_smaller$album_name, "\\b")
```


Here are the regular expression special characters that require an escape character (a preceding \ ): \ ^ $ . ? * | + ( ) [ {

For any characters with special properties, use \ to "escape" its special meaning ... but \ is itself a special character ... so we need two \\!  (e.g. \\$, \\., etc.)

```{r}
str_view(spot_smaller$title, "$")
str_view(spot_smaller$title, "\\$")
```


6. In bigspotify, how many track_names include a $?  Be sure you print the track_names you find and make sure the dollar sign is not just in a featured artist!


7. In bigspotify, how many track_names include a dollar amount (a $ followed by a number).


## Repetition

?  0 or 1 times
+  1 or more
*  0 or more
{n} exactly n times
{n,} n or more times
{,m} at most m times
{n,m} between n and m times

```{r}
str_view(spot_smaller$album_name, "[A-Z]{2,}")

str_view(spot_smaller$album_release_date, "\\d{4}-\\d{2}")
```


**Use at least 1 repetition symbol when solving 8-10 below**

8. Modify the first regular expression above to also pick up "m.A.A.d" (in addition to "BEYONC" and "II").  That is, pick up strings where there might be a period between capital letters.


9. Create some strings that satisfy these regular expressions and explain.

- "^.*$"
- "\\{.+\\}"


10. Create regular expressions to find all `stringr::words` that:

- Start with three consonants.
- Have two or more vowel-consonant pairs in a row.


## Useful functions for handling patterns

str_extract() : extract a string that matches a pattern
str_count() : count how many times a pattern occurs within a string


```{r}
str_extract(spot_smaller$album_release_date, "\\d{4}-\\d{2}")

spot_smaller |>
  select(album_release_date) |>
  mutate(year_month = str_extract(album_release_date, "\\d{4}-\\d{2}"))


spot_smaller |>
  select(artist) |>
  mutate(n_vowels = str_count(artist, "[aeiou]"))
```


11. In the spot_smaller dataset, how many words are in each title? (hint \\b)


12. In the spot_smaller dataset, extract the first word from every title. Show how you would print out these words as a vector and how you would create a new column on the spot_smaller tibble.  That is, produce this:

```{r}
# [1] "Hear"      "Run"       "Formation" "7/11"      "My"        "It's"     
# [7] "Poetic"    "A.D.H.D"   "Ya"        "Runnin"   
```
Then this:
```{r}
# A tibble: 10 × 2
#   title                                             first_word
#   <chr>                                             <chr>     
# 1 Hear Me Now                                       Hear      
# 2 Run the World (Girls)                             Run       
# 3 Formation                                         Formation 
# 4 7/11                                              7/11      
# 5 My Oh My (feat. DaBaby)                           My        
# 6 It's Automatic                                    It's      
# 7 Poetic Justice                                    Poetic    
# 8 A.D.H.D                                           A.D.H.D   
# 9 Ya Estuvo                                         Ya        
#10 Runnin (with A$AP Rocky, A$AP Ferg & Nicki Minaj) Runnin    
```


13. Which decades are popular for playlist_names? Using the bigspotify dataset, try doing each of these steps one at a time!

 - filter the bigspotify dataset to only include playlists that include something like "80's" or "00's" in their title.
 - create a new column that extracts the decade
 - use count to find how many playlists include each decade
 - what if you include both "80's" and "80s"? 
 - how can you count "80's" and "80s" together in your final tibble?


## Grouping and backreferences

```{r}
# find all fruits with repeated pair of letters.  
fruit = stringr::fruit
fruit
str_view(fruit, "(..)\\1", match = TRUE)

# why does the code below add "pepper" and even "nectarine"?
str_view(fruit, "(..)(.*)\\1", match = TRUE)
```

Tips with backreference: 
- You must use () around the the thing you want to reference.
- To backreference multiple times, use \\1 again.
- The number refers to which spot you are referencing... e.g. \\2 references the second set of () 

```{r}
x1 <- c("abxyba", "abccba", "xyaayx", "abxyab", "abcabc")
str_view(x1, "(.)(.)(..)\\2\\1")
str_view(x1, "(.)(.)(..)\\1\\2")
str_view(x1, "(.)(.)(.)\\1\\2\\3")
```


14. Describe to your groupmates what these expressions will match, and provide a word or expression as an example:

- (.)\1\1
- "(.)(.)(.).*\\3\\2\\1"

Which words in `stringr::words` match each expression?


15. Construct a regular expression to match words in `stringr::words` that contain a repeated pair of letters (e.g. “church” contains “ch” repeated twice) but *not* match repeated pairs of numbers (e.g. 507-786-3861).


16. Reformat the album_release_date variable in spot_smaller so that it is MM-DD-YYYY instead of YYYY-MM-DD.  (Hint: str_replace().)


17. BEFORE RUNNING IT, explain to your partner(s) what the following R chunk will do:

```{r}
sentences %>% 
  str_replace("([^ ]+) ([^ ]+) ([^ ]+)", "\\1 \\3 \\2") %>% 
  head(5)
```
